from scipy.interpolate import InterpolatedUnivariateSpline
import numpy as np
import pyseobnr
import time
import typer

from romgw.config.env import COMMON_TIME, PROJECT_ROOT
from romgw.typing.utils import validate_literal
from romgw.utils.filesystem import empty_directory
from romgw.waveform.params import PhysicalParams
from romgw.waveform.stat import ModelStat
from romgw.waveform.base import (
    ComponentWaveform,
    FullWaveform,
)
from romgw.typing.core import (
    RealArray,
    ComplexArray,
    MassRatio,
    SpinScalar,
    SpinVector,
    BBHSpinType,
    DatasetType,
    MODE_VALUES,
)

def interpolate(
    fiducial_h: ComplexArray,
    fiducial_time: RealArray,
    common_time: RealArray = COMMON_TIME
) -> ComplexArray:
    """
    Interpolate a waveform onto a common time grid.
    
    Waveforms generated by SEOBNRv5 are defined on non-uniform time grids
    that vary between simulations. This function interpolates waveforms
    onto a standardized common time grid for consistent analysis.
    
    Parameters
    ----------
    fiducial_h : ComplexArray of shape (n,)
        The waveform values defined on the fiducial time grid.
    fiducial_time : RealArray of shape (n,)
        The time grid on which the waveform is originally defined by
        SEOBNRv5.
    common_time : RealArray of shape (L,), optional
        The target time grid onto which the waveform is interpolated.
        Default is `_COMMON_TIME`.
    
    Returns
    -------
    common_h : ComplexArray of shape (L,)
        The interpolated waveform defined on the common time grid.
    """
    # Real part.
    imp_real = InterpolatedUnivariateSpline(x=fiducial_time,
                                            y=fiducial_h.real,
                                            k=5)
    common_h_real: RealArray = np.asarray(imp_real(common_time),
                                          dtype=np.float64)
    # Imaginary part.
    imp_imag = InterpolatedUnivariateSpline(x=fiducial_time,
                                            y=fiducial_h.imag,
                                            k=5)
    common_h_imag: RealArray = np.asarray(imp_imag(common_time),
                                          dtype=np.float64)

    common_h: ComplexArray = common_h_real + 1j * common_h_imag
    return common_h


def generate_seobnrv5_waveform(
    params: PhysicalParams
) -> tuple[dict[str, FullWaveform], ModelStat]:
    """
    Generate a waveform using SEOBNRv5.
    
    Uses SEOBNRv5 to generate s-2 weighted spherical harmonic modes modelling
    the gravitational waves from a binary black hole (BBH) merger with the
    given physical parameters. The waveforms are generated on a non-uniform
    time grid and then interpolated onto a common time grid for consistent
    analysis. Generation time is tracked.
    
    Parameters
    ----------
    params : PhysicalParams
        Contains the physical mass ratio and spins of a BBH. 
    
    Returns
    -------
    modes : dict of {str : FullWaveform}
        Dictionary mapping mode labels (e.g., "2,2", "3,3", "4,4") to
        their corresponding Waveform objects.
    stat : ModelStat
        Object containing the waveform generation time and waveform
        parameters.
    
    See Also
    --------
    interpolate : Interpolate waveform onto common time grid.
    """
    precessing = False if np.ndim(params.chi1) == 0 else True
    approximant = "SEOBNRv5HM" if not precessing else "SEOBNRv5PHM"

    q: MassRatio = params.q

    if precessing:
        chi1: SpinVector = params.chi1
        chi2: SpinVector = params.chi2
    else:
        chi1: SpinScalar = params.chi1
        chi2: SpinScalar = params.chi2

    start = time.perf_counter()
    res = pyseobnr.generate_waveform.generate_modes_opt(
        q=q,
        chi1=chi1,
        chi2=chi2,
        omega_start=0.015,
        omega_ref=0.015,
        approximant=approximant,
        debug=False
    )
    end = time.perf_counter()
    generation_time = end - start
    seobnrv5_time, modes = res[:2]

    for mode in modes:
        waveform_arr = interpolate(fiducial_h=modes[mode],
                                   fiducial_time=seobnrv5_time,
                                   common_time=COMMON_TIME)
        waveform = FullWaveform(waveform_arr, params)
        modes[mode] = waveform

    stat = ModelStat(approximant=approximant,
                     modes=list(modes.keys()),
                     generation_time=generation_time,
                     params=params)

    return modes, stat

HELP_BBH_SPIN = 'Spin configuration: "NS" = no-spin, "AS" = aligned-spin, "PS" = precessing-spin.'
HELP_DATASET = 'Dataset label: "train" = training data, "test" = testing data.'
HELP_SAVING = "Whether to save waveforms and their generation stats."
HELP_VERBOSE = "Enable verbose output."

app = typer.Typer(help="Reduced Order Modelling of Gravitational Waves CLI")

@app.command()
def main(
    bbh_spin: BBHSpinType = typer.Option(..., help=HELP_BBH_SPIN),
    dataset: DatasetType = typer.Option(..., help=HELP_DATASET),
    saving: bool = typer.Option(False, "--saving/--no-saving", help=HELP_SAVING),
    verbose: bool = typer.Option(False, "--verbose/--no-verbose", help=HELP_VERBOSE),
) -> None:
    """
    Generate fiducial waveforms for a dataset using SEOBNRv5.

    Generates waveforms for a spin-specific dataset using the parameter space
    created by `generate_parameter_space.py`. For each waveform, saves the
    complex waveform, its amplitude, phase, and generation statistics.

    Parameters
    ----------
    bbh_spin : BBHSpinType
        The complexity regarding the BBH spins. Can be "NS" (no-spin),
        "AS" (aligned-spin), or "PS" (precessing).
    dataset : DatasetType
        The dataset type. Can be "train" (training data)
        or "test" (testing data).
    saving : bool, optional
        If True, empties the relevant directories and saves the waveforms
        and stats returned by `generate_seobnrv5_waveform` calls.
        Default is False.
    verbose : bool, optional
        If True, prints progress updates. Default is False.

    Returns
    -------
    None

    See Also
    --------
    generate_seobnrv5_waveform : Generate waveform with SEOBNRv5.

    Examples
    --------
    Generate and save the no-spin waveforms for the traininig dataset:

        $ python generate_fiducial_waveforms.py --bbh-spin NS --dataset test --saving
    """
    bbh_spin = validate_literal(bbh_spin, BBHSpinType)
    dataset = validate_literal(dataset, DatasetType)

    dataset_dir = PROJECT_ROOT / "data" / bbh_spin / dataset

    param_space_filepath = dataset_dir / "parameter_space.npy"
    param_space = np.load(param_space_filepath)

    lsM = len(str((M := param_space.shape[0]) - 1))  # for printing

    if saving:
        # Empty directories to save to.
        # Avoids issues with reusing directories.
        stat_dir = dataset_dir / "stats"
        stat_dir.mkdir(parents=True, exist_ok=True)
        empty_directory(stat_dir)

        for path in dataset_dir.iterdir():
            if path.is_dir() and path.name in MODE_VALUES:
                for component in ("full", "amplitude", "phase"):
                    wf_dir = path / component / "raw"
                    wf_dir.mkdir(parents=True, exist_ok=True)
                    empty_directory(wf_dir)

    if verbose:
        typer.echo(f"Fiducial waveform generation for {bbh_spin=}, {dataset=}")

    for i, params in enumerate(param_space):
        # if verbose:
        #     print(f"Generating waveform {i+1:0{lsM}d}/{M}", end='\r')

        q: MassRatio = float(params[0])

        if bbh_spin == "PS":
            chi1: SpinVector = params[1:4].astype(np.float64)
            chi2: SpinVector = params[4:7].astype(np.float64)
        else:
            chi1: SpinScalar = float(params[1])
            chi2: SpinScalar = float(params[2])
        
        physical_params = PhysicalParams(q, chi1, chi2)
        
        modes, stat = generate_seobnrv5_waveform(params=physical_params)

        if saving:
            stat_file = stat_dir / f"stat_{i:0{lsM}d}.json"
            stat.to_file(stat_file)

        for mode in modes:
            waveform: FullWaveform = modes[mode]
            amplitude: ComponentWaveform = waveform.amplitude
            phase: ComponentWaveform = waveform.phase

            if saving:
                filename = f"waveform_{i:0{lsM}d}.npz"
                mode_dir = dataset_dir / mode

                wf_full_file = mode_dir / "full" / "raw" / filename
                waveform.to_file(wf_full_file)

                wf_amplitude_file = mode_dir / "amplitude" / "raw" / filename
                amplitude.to_file(wf_amplitude_file)

                wf_phase_file = mode_dir / "phase" / "raw" / filename
                phase.to_file(wf_phase_file)
    
    if verbose:
        typer.echo("Waveform generation complete.")

if __name__ == "__main__":
    app()
