from scipy.interpolate import InterpolatedUnivariateSpline
from typing import Dict, Tuple
import numpy as np
import pyseobnr
import time

from romgw.config.env import COMMON_TIME, PROJECT_ROOT
from romgw.typing.utils import validate_literal
from romgw.utils.filesystem import empty_directory
from romgw.waveform.params import PhysicalParams
from romgw.waveform.stat import ModelStat
from romgw.waveform.base import (
    ComponentWaveform,
    FullWaveform,
)
from romgw.typing.core import (
    RealArray,
    ComplexArray,
    MassRatio,
    SpinScalar,
    SpinVector,
    BBHSpinType,
    DatasetType,
    MODE_VALUES,
)


def interpolate(
    h_fiducial: ComplexArray,
    fiducial_time: RealArray,
    common_time: RealArray = COMMON_TIME
) -> ComplexArray:
    """
    Interpolate a waveform onto a common time grid.
    
    Waveforms generated by SEOBNRv5 are defined on non-uniform time grids
    that vary between simulations. This function interpolates waveforms
    onto a standardized common time grid for consistent analysis.
    
    Parameters
    ----------
    h_fiducial : ndarray of shape (n,)
        The waveform values defined on the fiducial time grid.
    fiducial_time : ndarray of shape (n,)
        The time grid on which the waveform is originally defined by
        SEOBNRv5.
    common_time : ndarray of shape (L,), optional
        The target time grid onto which the waveform is interpolated.
        Default is `_COMMON_TIME`.
    
    Returns
    -------
    h_common : ndarray of shape (L,)
        The interpolated waveform defined on the common time grid.
    """
    # Real part.
    imp_real = InterpolatedUnivariateSpline(x=fiducial_time,
                                            y=h_fiducial.real,
                                            k=5)
    h_common_real = np.asarray(imp_real(common_time), dtype=np.float64)
    # Imaginary part.
    imp_imag = InterpolatedUnivariateSpline(x=fiducial_time,
                                            y=h_fiducial.imag,
                                            k=5)
    h_common_imag = np.asarray(imp_imag(common_time), dtype=np.float64)
    # Complex sum.
    h_common = h_common_real + 1j * h_common_imag
    return h_common


def generate_seobnrv5_waveform(
    params: PhysicalParams
) -> Tuple[Dict[str, FullWaveform], ModelStat]:
    """
    Generate a waveform using SEOBNRv5.
    
    Uses SEOBNRv5 to generate s-2 weighted spherical harmonic modes modelling
    the gravitational waves from a binary black hole (BBH) merger with the
    given physical parameters. The waveforms are generated on a non-uniform
    time grid and then interpolated onto a common time grid for consistent
    analysis. Generation time is tracked.
    
    Parameters
    ----------
    q : float
        Mass ratio for the BBH. Must satisfy q >= 1.
    chi1 : float or ndarray of shape (3,)
        Dimensionless spin of the more massive BH. For no-spin (NS) and
        aligned-spin (AS) BBHs, provide the z-component as a float. For
        precessing (P) BBHs, provide the full 3D spin vector as an array.
    chi2 : float or ndarray of shape (3,)
        Dimensionless spin of the less massive BH. For no-spin (NS) and
        aligned-spin (AS) BBHs, provide the z-component as a float. For
        precessing (P) BBHs, provide the full 3D spin vector as an array.
    
    Returns
    -------
    modes : dict of {str : FullWaveform}
        Dictionary mapping mode labels (e.g., "2,2", "3,3", "4,4") to
        their corresponding Waveform objects.
    stat : ModelStat
        Object containing the waveform generation time and waveform
        parameters.
    
    See Also
    --------
    interpolate : Interpolate waveform onto common time grid.
    """
    # Choose approximant, guided by PhysicalParams.
    # PhysicalParams class enforces dimensional consistency across spins.
    precessing = False if np.ndim(params.chi1) == 0 else True
    approximant = "SEOBNRv5HM" if not precessing else "SEOBNRv5PHM"

    # Retrieve mass ratio from PhysicalParams.
    q: MassRatio = params.q

    # Retrieve spins from PhysicalParams.
    if precessing:  # RealArray of shape (3,)
        chi1: SpinVector = params.chi1
        chi2: SpinVector = params.chi2
    else:  # float
        chi1: SpinScalar = params.chi1
        chi2: SpinScalar = params.chi2

    # Generate the waveform modes and time it
    start = time.perf_counter()
    res = pyseobnr.generate_waveform.generate_modes_opt(
        q=q,
        chi1=chi1,
        chi2=chi2,
        omega_start=0.015,
        omega_ref=0.015,
        approximant=approximant,
        debug=False
    )
    end = time.perf_counter()
    generation_time = end - start
    seobnrv5_time, modes = res[:2]

    # Interpolate modes onto common time grid and make them Waveform instances.
    for mode in modes:
        # Interpolate fiducial waveform onto common time grid.
        waveform_arr = interpolate(h_fiducial=modes[mode],
                                   fiducial_time=seobnrv5_time,
                                   common_time=COMMON_TIME)
        # Instantiate as FullWaveform, retaining params.
        waveform = FullWaveform(waveform_arr=waveform_arr, params=params)
        # Update modes dict with FullWaveform instance.
        modes[mode] = waveform

    # Make FiducialStat instance for the waveform generation
    stat = ModelStat(approximant=approximant,
                     modes=list(modes.keys()),
                     generation_time=generation_time,
                     params=params)

    return modes, stat


def main(
    bbh_spin: BBHSpinType,
    dataset: DatasetType,
    saving: bool = False
) -> None:
    """
    Generate fiducial waveforms for a dataset using SEOBNRv5.

    Generates waveforms for a spin-specific dataset using the parameter space
    created by `generate_parameter_space.py`. For each waveform, saves the
    complex waveform, its amplitude, phase, and generation statistics.

    Parameters
    ----------
    spin : {"NS", "AS", "PS"}
        The complexity regarding the BBH spins. "NS" for no-spin, "AS" for
        aligned-spin, or "P" for precessing.
    dataset : {"train", "test"}
        The dataset type. "train" for training data (larger) or "test" for
        testing data (smaller).
    saving: bool
        Whether to save/perform filesystem operations or not.

    Returns
    -------
    None

    See Also
    --------
    generate_seobnrv5_waveform : Generate waveform with SEOBNRv5.
    """
    # Validate literals. Raises exception if invalid.
    bbh_spin = validate_literal(bbh_spin, BBHSpinType)
    dataset = validate_literal(dataset, DatasetType)

    # Every directory in this script is a child of this one.
    dataset_dir = PROJECT_ROOT / "data" / bbh_spin / dataset

    # Load the parameter space.
    param_space_filepath = dataset_dir / "parameter_space.npy"
    param_space = np.load(param_space_filepath)

    # For filename/printing purposes.
    lsM = len(str((M := param_space.shape[0]) - 1))

    # Empty directories to save to,
    # to avoid issues with reusing directories.
    if saving:
        # Generation time directory.
        stat_dir = dataset_dir / "stats"
        stat_dir.mkdir(parents=True, exist_ok=True)
        empty_directory(stat_dir)

        # Mode directories.
        for path in dataset_dir.iterdir():
            if path.is_dir() and path.name in MODE_VALUES:
                for component in ("full", "amplitude", "phase"):
                    wf_dir = path / component / "raw"
                    wf_dir.mkdir(parents=True, exist_ok=True)
                    empty_directory(wf_dir)

    for i, params in enumerate(param_space):
        print(f"Generating waveform {i+1:0{lsM}d}/{M}", end='\r')

        # Retrieve mass ratio from params array.
        q: MassRatio = float(params[0])

        # Retrieve spins from params array.
        if bbh_spin == "PS":
            chi1: SpinVector = params[1:4].astype(np.float64)
            chi2: SpinVector = params[4:7].astype(np.float64)
        else:
            chi1: SpinScalar = float(params[1])
            chi2: SpinScalar = float(params[2])
        
        # Instantiate params as PhysicalParams,
        # ensuring enforcement of param constraints.
        physical_params = PhysicalParams(q, chi1, chi2)
        
        # Generate waveform with fiducial model.
        modes, stat = generate_seobnrv5_waveform(params=physical_params)
        # print(f"{modes=}")
        # print(f"{stat=}")

        # Save stat.
        if saving:
            stat_file = stat_dir / f"stat_{i:0{lsM}d}.json"
            stat.to_file(stat_file)

        for mode in modes:
            # Full mode waveform.
            waveform: FullWaveform = modes[mode]
            # Amplitude for mode waveform.
            amplitude: ComponentWaveform = waveform.amplitude
            # Phase for mode waveform.
            phase: ComponentWaveform = waveform.phase

            # Saving.
            if saving:
                # Set filename for waveforms to save to.
                filename = f"waveform_{i:0{lsM}d}.npz"

                # 'Mode-anchored' directory.
                mode_dir = dataset_dir / mode

                # Full mode waveform.
                wf_full_file = mode_dir / "full" / "raw" / filename
                waveform.to_file(wf_full_file)

                # Amplitude of mode waveform.
                wf_amplitude_file = mode_dir / "amplitude" / "raw" / filename
                amplitude.to_file(wf_amplitude_file)

                # Phase of mode waveform.
                wf_phase_file = mode_dir / "phase" / "raw" / filename
                phase.to_file(wf_phase_file)
                
    print("Waveform generation complete.")


if __name__ == "__main__":
    main(bbh_spin="NS",
         dataset="test",
         saving=True)
